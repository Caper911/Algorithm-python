### 堆排序算法
**把一个待排序的数据元素序列构成一个完全二叉树结构，则每次选择出一个最大(或最小)的数据元素，只需要比较完全二叉树的深度次，既lbn次，这就是堆排序的基本思想**
****
#### 算法思想  
* **堆的定义**  
**堆分为最大堆(大顶堆/大根堆)和最小堆(小顶堆/小根堆)两种**  
* **堆的存储**  
**一般用数组来表示堆，若根节点存在于序号0处，i结点的父结点下表就为[(i-1) //  2],i结点的左右子结点下标分别为[2i+1]和[2i+2]**  
* **最大堆/最小堆的定义**  
**最大堆的父节点的数据元素比它的子节点都要大，而最小堆则相反父节点的数据都要比子节点的数据都要小**
**<br>最大堆的根节点是堆中值最大的数据元素，而最小堆的根节点是值最小的数据元素，对于最大堆，从根节点到每个叶节点的路径上，数据元素组成的序列都是递减有序的，而最小堆则相反是递增有序的。**

* **创建堆\最大堆调整**  
**给定一个序列，首先，根据该序列元素构造一个完全二叉树；然后，从最后一个非叶子结点开始，每次都是从父结点、左孩子节点、右孩子节点中进行比较交换，交换可能会引起孩子结点不满足堆的性质，所以每次交换之后需要重新对被交换的孩子结点进行调整。**

* **堆排序**  
 **每次形成最大堆后，都把堆顶元素和当前最大堆的最后一个元素交换。由于交换后根节点不再满足最大堆的定义，因此需要继续调整根节点使之满足。**
#### 复杂度
**堆排序算法是基于完全二叉树的排序，因为把一个完全二叉树调整为堆，以及每次堆顶元素交换后进行调整的时间复杂度均为O(lbn) 故堆排序算法的时间复杂度为O(nlbn)**<br>
**堆排序算法是一种不稳定的排序方法**
 
 ****
#### 代码实现
```
## 构造最大堆
def BuildHeap(lists, size):
    for i in range(0, (size // 2))[::-1]:
        AdjustHeap(lists, i, size)


def AdjustHeap(lists, i, size):
    
    #i结点的左右子结点下标分别为[2i+1]和[2i+2]
    lchild = 2 * i + 1
    rchild = 2 * i + 2
    max_ = i
    if i < size // 2:
        if lchild < size and lists[lchild] > lists[max_]:
            max_ = lchild
        if rchild < size and lists[rchild] > lists[max_]:
            max_ = rchild
        if max_ != i:
            lists[max_], lists[i] = lists[i], lists[max_]
            AdjustHeap(lists, max_, size)
 

def HeapSort(lists):
    size = len(lists)
    BuildHeap(lists, size)
    # 把调整后的最大堆顶点放到序列后方
    for i in range(0, size)[::-1]:
        lists[0], lists[i] = lists[i], lists[0]
        
        # 重新调整根节点使之满足最大堆
        AdjustHeap(lists, 0, i)
        
    return lists
```
 
